# ============================================
# Monorepo 通用部署 Makefile
# ============================================

# --- 基础配置 ---
APP_NAME ?= $(shell basename $(CURDIR))
APP_TYPE ?= $(shell if [ -f "next.config.js" ] || [ -f "vite.config.ts" ] || [ -f "vite.config.js" ]; then echo "frontend"; else echo "backend"; fi)
VERSION ?= latest
ENV_MODE ?= test  # local | test | prod
USE_SUDO ?= true

# --- 路径配置 ---
MONOREPO_ROOT ?= $(shell git rev-parse --show-toplevel 2>/dev/null || cd ../.. && pwd)
BUILD_CONTEXT ?= $(MONOREPO_ROOT)
DOCKERFILE ?= Dockerfile

# --- 环境配置 (根据你的实际环境修改) ---
ifeq ($(ENV_MODE), local)
  REGISTRY_HOST = localhost:5000
  REMOTE_USER = $(shell whoami)
  REMOTE_HOST = localhost
  REMOTE_COMPOSE_PATH = .
  LOCAL_COMPOSE_FILE = docker-compose.local.yaml
else ifeq ($(ENV_MODE), test)
  REGISTRY_HOST = registry.example.com:5000
  REMOTE_USER = root
  REMOTE_HOST = test-server
  REMOTE_COMPOSE_PATH = /opt/docker-composes
  LOCAL_COMPOSE_FILE = docker-compose.test.yaml
else ifeq ($(ENV_MODE), prod)
  REGISTRY_HOST = registry.example.com:5000
  REMOTE_USER = deploy
  REMOTE_HOST = prod-server
  REMOTE_COMPOSE_PATH = ~/docker-composes
  LOCAL_COMPOSE_FILE = docker-compose.yaml
endif

FULL_REGISTRY_IMAGE = $(REGISTRY_HOST)/$(APP_NAME):$(VERSION)
SUDO_CMD = $(if $(USE_SUDO),sudo,)

# --- 颜色定义 ---
GREEN = \033[0;32m
YELLOW = \033[1;33m
RED = \033[0;31m
NC = \033[0m

# ============================================
# 1. 本地开发测试
# ============================================

.PHONY: test local-dev

test: ## 本地 Docker 测试
	@echo "$(YELLOW)启动 $(APP_TYPE) 应用: $(APP_NAME)$(NC)"
	docker compose -f $(LOCAL_COMPOSE_FILE) up --build

local-dev: ## 本地开发 (不使用 Docker)
	@echo "$(YELLOW)启动本地开发服务$(NC)"
	@if [ -f "package.json" ]; then \
		pnpm dev || npm run dev; \
	else \
		echo "$(RED)未找到 package.json$(NC)"; \
	fi

# ============================================
# 2. 镜像构建
# ============================================

.PHONY: build build-arm save tag

build-arm: ## ARM 架构构建
	@echo "$(YELLOW)构建 ARM 镜像: $(APP_NAME):$(VERSION)$(NC)"
	docker build -t $(APP_NAME):$(VERSION) -f $(DOCKERFILE) $(BUILD_CONTEXT)

build: ## AMD64 架构构建
	@echo "$(YELLOW)构建 AMD64 镜像: $(APP_NAME):$(VERSION)$(NC)"
	docker buildx build --platform linux/amd64 -t $(APP_NAME):$(VERSION) -f $(DOCKERFILE) $(BUILD_CONTEXT)

save: build ## 保存镜像到文件
	@echo "$(YELLOW)保存镜像到文件$(NC)"
	docker save $(APP_NAME):$(VERSION) -o ./$(APP_NAME)-$(VERSION).tar
	@echo "$(GREEN)已保存: $(APP_NAME)-$(VERSION).tar$(NC)"

tag: build ## 打标签
	@echo "$(YELLOW)打标签: $(FULL_REGISTRY_IMAGE)$(NC)"
	docker tag $(APP_NAME):$(VERSION) $(FULL_REGISTRY_IMAGE)

# ============================================
# 3. 镜像推送
# ============================================

.PHONY: push remote-pull

push: tag ## 推送到镜像仓库
	@echo "$(YELLOW)推送镜像: $(FULL_REGISTRY_IMAGE)$(NC)"
	docker push $(FULL_REGISTRY_IMAGE)
	@echo "$(GREEN)推送完成$(NC)"

remote-pull: push ## 远程拉取镜像
	@echo "$(YELLOW)远程拉取镜像$(NC)"
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "$(SUDO_CMD) docker pull $(FULL_REGISTRY_IMAGE)"

# ============================================
# 4. 部署管理
# ============================================

.PHONY: push-compose-file remote-deploy remote-restart remote-logs remote-status

push-compose-file: push ## 推送 compose 文件
	@echo "$(YELLOW)推送 compose 文件到 $(REMOTE_HOST)$(NC)"
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "mkdir -p $(REMOTE_COMPOSE_PATH)"
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "rm -f $(REMOTE_COMPOSE_PATH)/$(APP_NAME).yaml"
	scp $(LOCAL_COMPOSE_FILE) $(REMOTE_USER)@$(REMOTE_HOST):$(REMOTE_COMPOSE_PATH)/$(APP_NAME).yaml
	@echo "$(GREEN)推送完成$(NC)"

remote-deploy: push local-clean push-compose-file ## 完整远程部署
	@echo "$(YELLOW)开始远程部署: $(APP_NAME)$(NC)"
	@echo "1. 停止旧服务..."
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "cd $(REMOTE_COMPOSE_PATH) && $(SUDO_CMD) docker compose -f $(APP_NAME).yaml down || true"
	@echo "2. 拉取新镜像..."
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "cd $(REMOTE_COMPOSE_PATH) && $(SUDO_CMD) docker compose -f $(APP_NAME).yaml pull"
	@echo "3. 启动新服务..."
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "cd $(REMOTE_COMPOSE_PATH) && $(SUDO_CMD) docker compose -f $(APP_NAME).yaml up -d"
	@echo "$(GREEN)部署完成!$(NC)"

remote-restart: ## 仅重启服务
	@echo "$(YELLOW)重启远程服务$(NC)"
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "cd $(REMOTE_COMPOSE_PATH) && $(SUDO_CMD) docker compose -f $(APP_NAME).yaml restart"

remote-logs: ## 查看远程日志
	@echo "$(YELLOW)查看日志: $(APP_NAME)$(NC)"
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "docker logs -f --tail=100 $(APP_NAME)"

remote-status: ## 查看服务状态
	@echo "$(YELLOW)服务状态$(NC)"
	ssh $(REMOTE_USER)@$(REMOTE_HOST) "docker ps | grep $(APP_NAME) || echo '服务未运行'"

# ============================================
# 5. 清理维护
# ============================================

.PHONY: local-clean docker-clean

local-clean: ## 清理本地镜像
	@echo "$(YELLOW)清理本地镜像$(NC)"
	docker rmi $(APP_NAME):$(VERSION) 2>/dev/null || true
	docker rmi $(FULL_REGISTRY_IMAGE) 2>/dev/null || true

docker-clean: ## 清理 Docker 缓存
	@echo "$(YELLOW)清理 Docker 缓存$(NC)"
	docker system prune -f

# ============================================
# 6. 工具命令
# ============================================

.PHONY: help info

help: ## 显示帮助
	@printf "$(YELLOW)应用: $(GREEN)$(APP_NAME)$(NC) | 类型: $(GREEN)$(APP_TYPE)$(NC) | 环境: $(GREEN)$(ENV_MODE)$(NC)\n"
	@printf "\n$(GREEN)可用命令:$(NC)\n"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  %-20s %s\n", $$1, $$2}'

info: ## 显示配置信息
	@echo "============================================"
	@echo "应用名称: $(APP_NAME)"
	@echo "应用类型: $(APP_TYPE)"
	@echo "当前版本: $(VERSION)"
	@echo "环境模式: $(ENV_MODE)"
	@echo "镜像仓库: $(REGISTRY_HOST)"
	@echo "远程主机: $(REMOTE_USER)@$(REMOTE_HOST)"
	@echo "完整镜像: $(FULL_REGISTRY_IMAGE)"
	@echo "============================================"

# ============================================
# 使用示例
# ============================================
# 本地测试: make test
# 生产部署: make ENV_MODE=prod remote-deploy
# 指定版本: make VERSION=v1.2.3 push
# 查看日志: make remote-logs
# ============================================
