# 组件开发检查清单

> **版本**: 1.0
> **适用场景**: 组件开发全流程

---

## 📋 组件开发全流程检查清单

### 阶段 1: 设计阶段（编码前）

#### ✅ 需求分析
- [ ] 明确组件职责和边界
- [ ] 确定组件类型（基础/业务/容器/页面）
- [ ] 识别组件输入（props）
- [ ] 识别组件输出（UI/事件）
- [ ] 识别状态管理需求
- [ ] 识别数据来源

#### ✅ 架构设计 [必须调用]
- [ ] **调用**: `@architecture-assistant 帮我设计一个 [组件名] 组件`
- [ ] 确认组件层次结构
- [ ] 确认职责划分
- [ ] 确认组件通信方案
- [ ] 确认数据流设计
- [ ] 确认可测试性设计

#### ✅ 规范确认 [必须调用]
- [ ] **调用**: `@frontend/components 请提供组件开发规范`
- [ ] 确认命名规范
- [ ] 确认代码风格
- [ ] 确认样式要求
- [ ] 确认工具配置

#### ✅ 设计原则检查
- [ ] **SoC**: UI、逻辑、数据是否分离？
- [ ] **SRP**: 组件是否只做一件事？
- [ ] **KISS**: 设计是否简单？
- [ ] **组合优于继承**: 是否使用组合模式？
- [ ] **高内聚低耦合**: 职责是否明确？
- [ ] **显式依赖**: 依赖是否通过 props 注入？
- [ ] **可测试性**: 是否易于测试？

---

### 阶段 2: 编码阶段

#### ✅ 文件命名
- [ ] 组件文件使用 PascalCase（如 `Button.tsx`）
- [ ] 页面文件使用 camelCase（如 `homePage.tsx`）
- [ ] Hook 文件使用 camelCase + use（如 `useModal.ts`）
- [ ] Index 文件使用 lowercase（如 `index.tsx`）

#### ✅ TypeScript 类型
- [ ] 定义 Props 接口（`ComponentNameProps`）
- [ ] 所有 Props 属性有类型注解
- [ ] 可选属性使用 `?` 标记
- [ ] 复杂类型有单独的接口定义
- [ ] 避免使用 `any` 类型
- [ ] 使用 `unknown` 替代 `any`
- [ ] 使用 React 类型（`FC`, `ReactNode`, `ReactElement`）
- [ ] 事件处理函数有正确类型

#### ✅ Props 设计
- [ ] Props 命名使用 camelCase
- [ ] 必需属性没有 `?` 标记
- [ ] 可选属性有默认值或处理
- [ ] 复杂对象有明确的接口定义
- [ ] 避免传递过多 props（>5 个考虑拆分）
- [ ] 使用显式依赖注入

#### ✅ 组件结构
- [ ] 使用函数组件（`const Component: FC<Props>`）
- [ ] 使用 `React.FC` 类型
- [ ] 组件名与文件名一致
- [ ] 导出使用命名导出（`export const`）
- [ ] 设置 `displayName`（用于调试）

#### ✅ Hooks 使用
- [ ] 自定义 Hook 命名使用 `use` 前缀
- [ ] 使用 `useState` 管理状态
- [ ] 使用 `useEffect` 处理副作用
- [ ] 使用 `useCallback` 优化事件处理
- [ ] 使用 `useMemo` 优化计算结果
- [ ] 依赖数组完整且正确
- [ ] 避免在循环/条件中使用 Hooks

#### ✅ 状态管理
- [ ] 状态命名使用 camelCase（如 `isOpen`, `userData`）
- [ ] 事件处理命名使用 `handle` 前缀（如 `handleClick`）
- [ ] 复杂状态考虑使用 `useReducer`
- [ ] 状态提升到最近的公共父组件
- [ ] 避免不必要的状态

#### ✅ 样式系统
- [ ] 使用 UnoCSS 类名
- [ ] 使用 CSS 变量（如 `var(--color-primary)`）
- [ ] 无内联样式（`style={{}}`）
- [ ] 使用快捷方式（如 `btn-primary`）
- [ ] 支持暗色主题
- [ ] 响应式设计

#### ✅ 事件处理
- [ ] 使用 `useCallback` 优化
- [ ] 依赖数组正确
- [ ] 避免内联箭头函数（如 `onClick={() => handleClick()}`）
- [ ] 事件处理函数命名清晰
- [ ] 防止重复点击（loading/disabled 状态）

#### ✅ 性能优化
- [ ] 使用 `memo` 优化纯组件
- [ ] 使用 `useCallback` 优化事件处理
- [ ] 使用 `useMemo` 优化计算结果
- [ ] 避免不必要的重新渲染
- [ ] 正确管理依赖数组
- [ ] 使用 `key` 优化列表渲染

#### ✅ 错误处理
- [ ] 处理可能的 null/undefined
- [ ] 使用可选链（`?.`）
- [ ] 使用空值合并（`??`）
- [ ] 提供错误边界（Error Boundary）
- [ ] 错误信息清晰

#### ✅ 代码质量
- [ ] 代码简洁（<200 行）
- [ ] 无重复代码（DRY）
- [ ] 函数职责单一
- [ ] 变量命名清晰
- [ ] 注释清晰（中文）
- [ ] 复杂逻辑有注释

---

### 阶段 3: 审查阶段（编码后）

#### ✅ 架构审查 [必须调用]
- [ ] **调用**: `@architecture-assistant 请审查这段组件代码`
- [ ] 检查 10 大设计原则遵循情况
- [ ] 检查架构合理性
- [ ] 检查可测试性
- [ ] 检查潜在反模式
- [ ] 修复所有严重问题

#### ✅ 前端规范审查 [必须调用]
- [ ] **调用**: `@frontend/components 请检查这个组件`
- [ ] 检查命名是否符合规范
- [ ] 检查 TypeScript 类型完整性
- [ ] 检查代码风格
- [ ] 检查样式系统使用
- [ ] 检查性能优化

#### ✅ 自我审查
- [ ] 运行 `pnpm lint` 检查代码质量
- [ ] 运行类型检查（`tsc --noEmit`）
- [ ] 运行构建（`pnpm build`）
- [ ] 检查 ESLint 错误
- [ ] 检查 TypeScript 错误

#### ✅ 文档化
- [ ] 如有重要决策，创建 ADR
- [ ] **调用**: `@architecture-assistant 为 [决策] 创建 ADR`
- [ ] 更新组件文档
- [ ] 添加使用示例

---

### 阶段 4: 提交前检查

#### ✅ 规范合规性
- [ ] 命名规范符合要求
- [ ] TypeScript 类型完整
- [ ] 代码风格一致
- [ ] 样式系统正确使用

#### ✅ 架构原则合规性
- [ ] 遵循 SoC（关注点分离）
- [ ] 遵循 SRP（单一职责）
- [ ] 遵循 DRY（不重复）
- [ ] 遵循 KISS（保持简单）
- [ ] 使用组合优于继承
- [ ] 高内聚低耦合
- [ ] 显式依赖注入
- [ ] 可测试性良好

#### ✅ 代码质量
- [ ] 无严重问题（原则违反数 < 2）
- [ ] 通过架构技能审查
- [ ] 通过前端规范检查
- [ ] 通过类型检查
- [ ] 通过构建
- [ ] 通过 Lint

#### ✅ 文档和 ADR
- [ ] ADR 已创建（如需要）
- [ ] 文档已更新
- [ ] 使用示例已添加

#### ✅ 最终检查
- [ ] 运行 `pnpm lint` 无错误
- [ ] 运行 `tsc --noEmit` 无错误
- [ ] 运行 `pnpm build` 成功
- [ ] 组件功能正常
- [ ] 无性能问题

---

## 🎯 按组件类型检查

### 基础组件检查清单

#### UI 组件（Button, Input, Card）
- [ ] 纯 UI 展示，无业务逻辑
- [ ] Props 简单明了
- [ ] 支持多种变体（variant）
- [ ] 支持尺寸调整（size）
- [ ] 支持禁用状态（disabled）
- [ ] 支持加载状态（loading）
- [ ] 使用 UnoCSS 样式
- [ ] 使用 CSS 变量
- [ ] 无状态管理
- [ ] 易于测试

### 业务组件检查清单

#### 业务组件（UserProfile, ArticleCard）
- [ ] 职责单一（UI + 相关业务）
- [ ] 使用 Hooks 管理状态
- [ ] 通过 props 接收数据
- [ ] 通过 props 接收回调
- [ ] 处理用户交互
- [ ] 处理错误状态
- [ ] 处理加载状态
- [ ] 使用 memo 优化性能
- [ ] 使用 useCallback 优化事件

### 容器组件检查清单

#### 容器组件（UserListContainer）
- [ ] 职责：数据管理
- [ ] 使用自定义 Hooks 获取数据
- [ ] 处理加载状态
- [ ] 处理错误状态
- [ ] 渲染 UI 组件
- [ ] 不包含 UI 逻辑
- [ ] 通过 props 传递数据
- [ ] 通过 props 传递回调

### 页面组件检查清单

#### 页面组件（HomePage）
- [ ] 职责：路由级组合
- [ ] 组合布局组件
- [ ] 组合容器组件
- [ ] 组合业务组件
- [ ] 处理页面级状态
- [ ] 处理路由参数
- [ ] 处理页面生命周期

### 布局组件检查清单

#### 布局组件（MainLayout）
- [ ] 职责：页面结构
- [ ] 提供布局容器
- [ ] 处理导航/侧边栏
- [ ] 处理响应式布局
- [ ] 使用 CSS Grid/Flexbox
- [ ] 不包含业务逻辑

---

## 🔍 常见问题检查

### 命名问题
- [ ] 组件文件不是 PascalCase
- [ ] Props 接口不是 PascalCase + Props
- [ ] Props 属性不是 camelCase
- [ ] 状态变量不是 camelCase
- [ ] 事件处理不是 camelCase + handle
- [ ] 常量不是 UPPER_SNAKE_CASE

### 类型问题
- [ ] 使用 `any` 类型
- [ ] 缺少 Props 类型定义
- [ ] 缺少返回值类型
- [ ] 使用 `Function` 类型
- [ ] 使用 `object` 类型

### 架构问题
- [ ] 组件职责过多（>3 个）
- [ ] UI 和逻辑混在一起
- [ ] 数据获取在组件内部
- [ ] 使用全局变量
- [ ] 缺少错误处理
- [ ] 缺少加载状态

### 性能问题
- [ ] 缺少 `memo` 优化
- [ ] 缺少 `useCallback` 优化
- [ ] 缺少 `useMemo` 优化
- [ ] 依赖数组错误
- [ ] 不必要的重新渲染
- [ ] 内联函数导致重渲染

### 样式问题
- [ ] 使用内联样式
- [ ] 混合多种样式方案
- [ ] 没有使用 CSS 变量
- [ ] 没有使用 UnoCSS
- [ ] 不支持暗色主题

---

## 📊 质量评分

### 优秀（90-100 分）
- ✅ 遵循 9-10 个核心原则
- ✅ 通过架构技能审查
- ✅ 通过前端规范检查
- ✅ 有清晰的 ADR（如需要）
- ✅ 易于测试和维护
- ✅ 代码简洁清晰

### 合格（70-89 分）
- ✅ 遵循 7-8 个核心原则
- ✅ 无严重反模式
- ✅ 基本可测试
- ✅ 通过基本审查

### 不合格（<70 分）
- ❌ 违反 3+ 个核心原则
- ❌ 存在 God Object
- ❌ 严重耦合或循环依赖
- ❌ 未使用技能审查

---

## 🚀 快速检查命令

```bash
# 1. 代码格式化
pnpm lint

# 2. 类型检查
tsc --noEmit

# 3. 构建检查
pnpm build

# 4. 运行测试（如有）
pnpm test

# 5. 全面检查
pnpm lint && tsc --noEmit && pnpm build
```

---

## 📝 检查记录模板

```markdown
## 组件开发检查记录

**组件名称**: [组件名]
**开发日期**: [日期]
**开发者**: [姓名]

### 设计阶段
- [ ] 架构设计: @architecture-assistant
- [ ] 规范确认: @frontend/components

### 编码阶段
- [ ] 命名规范: ✅/❌
- [ ] TypeScript 类型: ✅/❌
- [ ] Hooks 使用: ✅/❌
- [ ] 样式系统: ✅/❌
- [ ] 性能优化: ✅/❌

### 审查阶段
- [ ] 架构审查: @architecture-assistant
- [ ] 前端审查: @frontend/components
- [ ] 类型检查: ✅/❌
- [ ] 构建检查: ✅/❌

### 问题记录
1. [问题描述] - [解决方案]
2. [问题描述] - [解决方案]

### 质量评分
- 架构原则: [分数]/10
- 前端规范: [分数]/10
- 代码质量: [分数]/10
- **总分**: [总分]/100

### 结论
✅ 通过 / ❌ 需要改进

**审查人**: [姓名]
**日期**: [日期]
```

---

## 💡 提示

### 何时必须调用技能
- ✅ 创建新组件时
- ✅ 重构复杂组件时
- ✅ 遇到设计问题时
- ✅ 性能优化时
- ✅ 代码审查时

### 何时可以自行检查
- ✅ 简单的 UI 调整
- ✅ 明显的 bug 修复
- ✅ 文档更新
- ✅ 类型修正

### 何时需要咨询架构师
- ✅ 复杂的组件架构
- ✅ 重要的技术决策
- ✅ 性能瓶颈
- ✅ 可测试性问题

---

**版本**: 1.0
**状态**: 已批准
**最后更新**: 2026-01-19
**适用范围**: 所有前端组件开发
