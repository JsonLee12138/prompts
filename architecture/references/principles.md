# 软件架构设计原则

> **版本**: 2.0
> **状态**: 已批准
> **适用范围**: 所有语言和项目
> **最后更新**: 2026-01-12

---

## 目录

1. [核心原则](#核心原则)
2. [质量属性](#质量属性)
3. [技术指南](#技术指南)
4. [决策框架](#决策框架)
5. [反模式](#反模式)
6. [多语言示例](#多语言示例)
7. [实施检查清单](#实施检查清单)

---

## 核心原则

### 1. 关注点分离 (Separation of Concerns - SoC)

**原则**: 将系统划分为功能明确且重叠最小的不同部分。

**为什么重要**:
- 降低模块间的耦合度
- 提高代码的可维护性
- 便于独立测试和部署
- 支持团队并行开发

**实践要点**:
- 每个模块/层有明确的职责边界
- 业务逻辑与基础设施分离
- UI/展示逻辑与业务逻辑分离
- 数据访问与业务规则分离

**检查问题**:
- 这个类/模块是否承担了多个职责？
- 修改一个功能是否需要修改多个地方？
- 能否独立测试这个模块？

**适用场景**:
- Web 应用（MVC/MVVM）
- 微服务架构
- 分层架构
- 事件驱动系统

---

### 2. 单一职责原则 (Single Responsibility Principle - SRP)

**原则**: 每个类、模块或函数应该只负责一个功能领域。

**为什么重要**:
- 代码更容易理解和维护
- 减少修改带来的副作用
- 提高可测试性
- 降低复杂度

**实践要点**:
- 一个类只有一种改变的理由
- 公共方法都服务于同一目标
- 依赖数量合理（通常 < 5）
- 职责可以用一句话描述

**检查问题**:
- 这个类有多少个公共方法？
- 这些方法是否都服务于同一个目标？
- 如果需求变化，这个类需要修改几次？

**适用场景**:
- 所有面向对象编程
- 函数式编程中的模块设计
- API 设计
- 数据库表设计

---

### 3. DRY原则 (Don't Repeat Yourself)

**原则**: 避免代码重复，通过抽象共享通用逻辑。

**为什么重要**:
- 减少维护成本
- 防止逻辑不一致
- 提高代码质量
- 降低 bug 几率

**实践要点**:
- 识别重复的模式
- 提取公共函数/类
- 使用参数化模板
- 建立共享库/包

**检查问题**:
- 相同逻辑是否出现在 2 个以上地方？
- 修改一处是否需要修改多处？
- 是否有可以提取的通用模式？

**适用场景**:
- 业务逻辑
- 验证规则
- 数据转换
- 工具函数

---

### 4. KISS原则 (Keep It Simple, Stupid)

**原则**: 保持简单，避免不必要的复杂性。

**为什么重要**:
- 降低理解成本
- 减少 bug
- 提高开发效率
- 易于维护

**实践要点**:
- 优先使用简单直接的方案
- 只为已知需求设计
- 质疑每一层抽象
- 避免过早优化

**检查问题**:
- 这个设计是否解决了当前问题？
- 是否有更简单的方法？
- 这个抽象是否必要？
- 能否用更少的代码实现？

**YAGNI原则**: 你不需要它（You Aren't Gonna Need It）
- 不要为未来可能的需求提前设计
- 需要时再重构

**适用场景**:
- 所有设计决策
- 代码实现
- 架构选择
- 工具引入

---

### 5. 组合优于继承 (Composition Over Inheritance)

**原则**: 优先使用组合，而不是继承来实现代码复用。

**为什么重要**:
- 更灵活，容易改变行为
- 降低耦合度
- 避免继承层次过深
- 减少脆弱基类问题

**实践要点**:
- 使用依赖注入
- 通过接口/契约组合功能
- 保持继承层次浅（最多 2-3 层）
- 继承仅用于真正的 "is-a" 关系

**检查问题**:
- 继承层次是否超过 2 层？
- 子类是否真的需要父类的所有行为？
- 能否用依赖注入替换继承？
- 是否有 "has-a" 关系误用为 "is-a"？

**适用场景**:
- 对象行为扩展
- 功能组合
- 插件系统
- 策略模式实现

---

### 6. 高内聚，低耦合 (High Cohesion, Low Coupling)

**原则**: 相关功能聚集在一起，模块间依赖最小化。

**为什么重要**:
- 模块可以独立开发和测试
- 变更影响范围小
- 系统更容易理解和演进
- 支持团队并行工作

**实践要点**:
- 相关功能放在同一模块
- 通过接口而非具体实现依赖
- 依赖方向指向核心业务
- 避免循环依赖

**检查问题**:
- 模块是否只关注一个领域？
- 依赖是否通过接口声明？
- 修改一个模块是否需要修改其他模块？
- 是否存在循环依赖？

**适用场景**:
- 微服务边界划分
- 模块/包设计
- 类/函数组织
- API 设计

---

### 7. 显式依赖 (Explicit Dependencies)

**原则**: 所有依赖都应该显式声明，不要隐藏。

**为什么重要**:
- 依赖关系清晰可见
- 便于测试和替换
- 避免隐藏的副作用
- 提高代码可读性

**实践要点**:
- 使用构造函数/参数注入
- 避免全局变量和单例
- 依赖抽象而非具体
- 不在内部创建依赖

**检查问题**:
- 所有外部依赖是否在构造函数/参数中声明？
- 是否使用了全局变量或单例？
- 能否轻松替换依赖进行测试？
- 依赖关系是否清晰可见？

**适用场景**:
- 类设计
- 函数签名
- 模块接口
- 服务组合

---

### 8. 快速失败 (Fail Fast and Loud)

**原则**: 尽早验证输入，出现错误时立即明确失败。

**为什么重要**:
- 问题在早期发现，易于调试
- 防止错误传播导致数据损坏
- 提供清晰的错误信息
- 降低故障排查成本

**实践要点**:
- 在边界处验证输入
- 使用明确的错误类型
- 提供可操作的错误信息
- 避免静默失败

**检查问题**:
- 输入验证是否在函数入口？
- 错误信息是否清晰可操作？
- 是否避免了静默失败？
- 错误是否及时向上传播？

**适用场景**:
- API 边界
- 数据验证
- 外部服务调用
- 配置加载

---

### 9. 不可变性优先 (Immutability by Default)

**原则**: 默认使用不可变数据结构，避免状态突变。

**为什么重要**:
- 状态可预测，易于推理
- 避免意外的副作用
- 线程安全
- 便于并发编程

**实践要点**:
- 使用不可变数据结构
- 更新时创建新对象而非修改
- 使用 `const` / `final` / `val` 等关键字
- 避免函数内的状态修改

**检查问题**:
- 函数是否修改输入参数？
- 是否使用不可变关键字？
- 数据更新是否创建新对象？
- 是否有共享的可变状态？

**适用场景**:
- 函数式编程
- 并发系统
- 状态管理
- 数据转换

---

### 10. 可测试性优先 (Testability First)

**原则**: 设计时就考虑如何测试。

**为什么重要**:
- 高测试覆盖率
- 重构有信心
- 文档化设计
- 促进良好架构

**实践要点**:
- 依赖注入
- 避免全局状态
- 小而专注的函数
- 清晰的输入输出

**检查问题**:
- 是否可以轻松 mock 所有依赖？
- 函数是否有清晰的输入输出？
- 是否避免了全局状态？
- 能否独立测试？

**适用场景**:
- 所有代码编写
- API 设计
- 服务组合
- 测试驱动开发

---

## 质量属性

### 性能 (Performance)

**原则**:
- 先测量，再优化
- 优化常见情况
- 设计时考虑性能

**关键指标**:
```
API 响应时间:
- P50: < 100ms
- P95: < 200ms
- P99: < 500ms

数据库查询:
- 简单查询: < 50ms
- 复杂查询: < 200ms

并发支持:
- 目标用户数 × 2 容量缓冲
```

**实践策略**:
- 使用缓存策略
- 数据库索引优化
- 异步处理长任务
- 监控性能指标
- 避免过早优化

---

### 安全性 (Security)

**原则**:
- 深度防御
- 永不信任输入
- 最小权限原则
- 安全失败

**检查清单**:
- [ ] 输入验证和清理
- [ ] SQL 注入防护（参数化查询）
- [ ] XSS 防护（输出编码）
- [ ] CSRF 防护
- [ ] 认证和授权
- [ ] 敏感数据加密
- [ ] 审计日志
- [ ] HTTPS 强制
- [ ] 密码安全（哈希加盐）
- [ ] API 速率限制
- [ ] 会话管理
- [ ] 错误信息不泄露敏感数据

---

### 可扩展性 (Scalability)

**原则**:
- 设计水平扩展
- 保持无状态
- 异步处理
- 数据库优化

**实践策略**:
- 无状态服务
- 会话外部存储（Redis）
- 消息队列解耦
- 读写分离
- 数据分片策略
- 缓存策略（多级缓存）
- 负载均衡

---

### 可维护性 (Maintainability)

**原则**:
- 代码即文档
- 一致的约定
- 清晰的结构
- 完整的文档

**实践策略**:
- 遵循语言/框架约定
- 清晰的命名
- 适当的注释（为什么，而非做什么）
- 提交信息规范
- 文档保持更新
- 代码审查
- 定期重构

---

## 技术指南

### API 设计

**RESTful 原则**:
```
✅ 正确的 URL 结构:
GET    /users           - 获取用户列表
GET    /users/{id}      - 获取单个用户
POST   /users           - 创建用户
PUT    /users/{id}      - 完全更新用户
PATCH  /users/{id}      - 部分更新用户
DELETE /users/{id}      - 删除用户

✅ 正确的 HTTP 状态码:
200 OK - 成功
201 Created - 创建成功
204 No Content - 删除成功
400 Bad Request - 客户端错误
401 Unauthorized - 未认证
403 Forbidden - 无权限
404 Not Found - 资源不存在
500 Internal Server Error - 服务端错误
```

**GraphQL 注意事项**:
- 避免 N+1 查询
- 使用 DataLoader 批量加载
- 实现分页
- 错误处理规范
- Schema 设计清晰

---

### 数据库设计

**原则**:
- 规范化到 3NF
- 索引策略
- 迁移计划
- 软删除考虑

**最佳实践**:
- 使用 UUID 作为主键（分布式系统）
- 所有表包含时间戳（created_at, updated_at, deleted_at）
- 外键约束保证数据完整性
- 索引策略基于查询模式
- 考虑分区策略（大表）
- 备份和恢复策略

---

### 前端架构

**组件原则**:
- 容器组件 vs 展示组件
- 单一职责
- 可复用 UI 组件
- 状态管理分层

**性能优化**:
- 路由懒加载
- 组件代码分割
- 图片优化（压缩、懒加载）
- 虚拟滚动
- 缓存策略

---

## 决策框架

当面临架构决策时，遵循以下流程：

### 1. 理解问题
```
- 问题是什么？
- 约束条件有哪些？
- 成功标准是什么？
- 影响范围？
```

### 2. 收集选项
```
- 列出至少 2-3 个可行方案
- 考虑：自建 vs 购买 vs 开源
- 研究行业标准
- 参考类似案例
```

### 3. 评估选项

使用评分矩阵：

| 标准 | 权重 | 选项 A | 选项 B | 选项 C |
|------|------|--------|--------|--------|
| 符合原则 | 30% | | | |
| 简单性 | 20% | | | |
| 成本 | 15% | | | |
| 维护性 | 15% | | | |
| 性能 | 10% | | | |
| 风险 | 10% | | | |

### 4. 记录决策

使用 ADR (Architecture Decision Record) 模板记录。

### 5. 审查和批准
- [ ] 同行评审
- [ ] 技术负责人批准
- [ ] 记录在案
- [ ] 通知团队

---

## 反模式

### 架构异味 (Architecture Smells)

#### 1. 神对象 (God Object)
**症状**: 一个类超过 500 行，有超过 10 个职责

**修复**: 拆分职责，遵循单一职责原则

---

#### 2. 循环依赖 (Circular Dependencies)
**症状**: A → B → A

**修复**: 提取公共依赖，使用依赖倒置

---

#### 3. 散弹式修改 (Shotgun Surgery)
**症状**: 一个需求变更需要修改多个文件

**修复**: 提高内聚性，提取公共模块

---

#### 4. 特性嫉妒 (Feature Envy)
**症状**: 一个方法过度使用另一个对象的数据

**修复**: 移动方法到数据所有者

---

#### 5. 重复代码 (Duplicate Code)
**症状**: 相同逻辑出现在多处

**修复**: 提取公共函数/类，遵循 DRY

---

## 多语言示例

每个原则都有对应的语言示例，请查看：

- [TypeScript 示例](../examples/typescript/)
- [Go 示例](../examples/golang/)
- [Rust 示例](../examples/rust/)
- [Python 示例](../examples/python/)
- [Java 示例](../examples/java/)

每个语言目录包含：
- `README.md` - 该语言的特定指南
- `principle-name.md` - 具体原则的代码示例

---

## 实施检查清单

### 项目启动检查

- [ ] 架构原则文档已创建并团队共识
- [ ] 代码规范已定义（linting, formatting）
- [ ] 目录结构已规划
- [ ] 技术栈已选择并记录理由
- [ ] 开发环境已标准化

### 设计阶段检查

- [ ] 模块边界已清晰定义
- [ ] 依赖关系已分析
- [ ] 接口设计已完成
- [ ] 数据模型已设计
- [ ] API 规范已制定

### 实施阶段检查

- [ ] 依赖注入已使用
- [ ] 单元测试已编写
- [ ] 集成测试已覆盖关键路径
- [ ] 日志和监控已添加
- [ ] 错误处理已完善

### 代码审查检查

- [ ] **单一职责**: 每个类/函数只做一件事
- [ ] **依赖清晰**: 所有依赖显式声明
- [ ] **测试覆盖**: 核心逻辑有测试
- [ ] **命名清晰**: 变量、函数名表意
- [ ] **注释必要**: 复杂逻辑有说明
- [ ] **无重复代码**: 遵循 DRY
- [ ] **简单设计**: 没有过度抽象

### 部署前检查

- [ ] 性能测试：关键路径已测试
- [ ] 安全扫描：已检查常见漏洞
- [ ] 文档更新：架构文档已同步
- [ ] 团队培训：新成员能理解设计

---

## 附录

### 术语表

| 术语 | 解释 |
|------|------|
| ADR | Architecture Decision Record - 架构决策记录 |
| API | Application Programming Interface - 应用程序接口 |
| CI/CD | Continuous Integration/Continuous Deployment - 持续集成/部署 |
| CRUD | Create, Read, Update, Delete - 增删改查 |
| DRY | Don't Repeat Yourself - 不重复自己 |
| KISS | Keep It Simple, Stupid - 保持简单 |
| MVP | Minimum Viable Product - 最小可行产品 |
| SoC | Separation of Concerns - 关注点分离 |
| YAGNI | You Aren't Gonna Need It - 你不需要它 |
| SOLID | 面向对象设计的五个原则 |
| ACID | 数据库事务的四个特性 |
| ORM | Object-Relational Mapping - 对象关系映射 |
| DI | Dependency Injection - 依赖注入 |
| TDD | Test-Driven Development - 测试驱动开发 |

### 推荐阅读

**基础理论**:
- 《代码大全》(Code Complete) - Steve McConnell
- 《重构》(Refactoring) - Martin Fowler
- 《设计模式》(Design Patterns) - GoF

**架构设计**:
- 《清洁架构》(Clean Architecture) - Robert C. Martin
- 《领域驱动设计》(DDD) - Eric Evans
- 《微服务架构》(Building Microservices) - Sam Newman

**实践指南**:
- 《程序员修炼之道》(The Pragmatic Programmer)
- 《架构整洁之道》(Clean Architecture)
- 《发布！软件的设计与部署》

### 工具推荐

**设计工具**:
- PlantUML / Mermaid - 架构图
- Draw.io - 流程图
- Miro - 协作设计

**代码质量**:
- SonarQube - 代码质量检查
- ESLint / Prettier - JavaScript 代码规范
- Black / isort - Python 代码规范
- gofmt - Go 代码规范
- rustfmt - Rust 代码规范

**测试工具**:
- Jest / Mocha - JavaScript 测试
- pytest - Python 测试
- JUnit - Java 测试
- go test - Go 测试
- cargo test - Rust 测试

**监控工具**:
- Prometheus + Grafana - 指标监控
- ELK Stack - 日志分析
- Sentry - 错误追踪

---

## 变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 2.0 | 2026-01-12 | 重构为通用原则，移除语言特定代码，创建多语言示例结构 | 架构团队 |
| 1.0 | 2026-01-12 | 初始版本 | 架构团队 |

---

**文档维护**: 架构团队
**审查周期**: 每季度
**下次审查**: 2026-04-12
**联系**: architecture@company.com
